<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <title>Shallow Water</title>
    <style>
            html, body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                width: 100%;
                height: 100%;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
    </style>
</head>
<body>
    <canvas></canvas>
    <div id="info"></div>
    <script>
        (async function () {
            const canvas = document.querySelector('canvas');
            const info = document.getElementById('info');

            if (!navigator.gpu) {
                info.textContent = 'WebGPU not supported in this browser.';
                return;
            }

            const shaderPaths = {
                height: 'shaders/heightfield.wgsl',
                gravity: 'shaders/gravity.wgsl',
                render: 'shaders/render.wgsl',
                caustics: 'shaders/caustics.wgsl'
            };

            const shaders = {};
            await Promise.all(Object.keys(shaderPaths).map(async (key) => {
                const res = await fetch(shaderPaths[key]);
                shaders[key] = await res.text();
            }));

            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const context = canvas.getContext('webgpu');
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const simResolution = 128;
            const causticsResolution = 512;

            const quadVertices = new Float32Array([
                -1, -1, 1, -1, -1, 1,
                1, -1, 1, 1, -1, 1
            ]);
            const quadBuffer = device.createBuffer({
                size: quadVertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(quadBuffer, 0, quadVertices);

            function createLightWaveVertices(width = 256, height = 256) {
                const verts = [];
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j < width; j++) {
                        const v1x = (i / height) * 2 - 1;
                        const v1y = (j / width) * 2 - 1;
                        const v2x = ((i + 1) / height) * 2 - 1;
                        const v2y = ((j + 1) / width) * 2 - 1;
                        verts.push(v1x, v1y, v1x, v2y, v2x, v2y);
                        verts.push(v1x, v1y, v2x, v2y, v2x, v1y);
                    }
                }
                return new Float32Array(verts);
            }

            const lightWaveVertices = createLightWaveVertices();
            const lightWaveBuffer = device.createBuffer({
                size: lightWaveVertices.byteLength,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(lightWaveBuffer, 0, lightWaveVertices);

            const uploadTextureUsage = GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT;

            function createTexture(size) {
                return device.createTexture({
                    size: [size, size, 1],
                    format: 'rgba16float',
                    usage: uploadTextureUsage
                });
            }

            const heightTexture0 = createTexture(simResolution);
            const heightTexture1 = createTexture(simResolution);
            const causticsTexture = device.createTexture({
                size: [causticsResolution, causticsResolution, 1],
                format: 'rgba16float',
                usage: uploadTextureUsage
            });

            function createInitialHeightData(size) {
                const data = new Float32Array(size * size * 4);
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const x = i / (size * 0.5) - 1.0;
                        const z = j / (size * 0.5) - 1.0;
                        const t = x * x + z * z;
                        const idx = (i * size + j) * 4;
                        data[idx] = 0.0;
                        data[idx + 1] = 0.0;
                        data[idx + 2] = t < 0.3 ? 0.09 * Math.sin(50.0 * t) : 0.0;
                        data[idx + 3] = 0.0;
                    }
                }
                return data;
            }

            const initialHeight = createInitialHeightData(simResolution);
            const bytesPerRow = simResolution * 8;
            [heightTexture0, heightTexture1].forEach((texture) => {
                device.queue.writeTexture(
                    { texture },
                    initialHeight,
                    { bytesPerRow, rowsPerImage: simResolution },
                    { width: simResolution, height: simResolution, depthOrArrayLayers: 1 }
                );
            });

            const causticsClear = new Float32Array(causticsResolution * causticsResolution * 4);
            device.queue.writeTexture(
                { texture: causticsTexture },
                causticsClear,
                { bytesPerRow: causticsResolution * 8, rowsPerImage: causticsResolution },
                { width: causticsResolution, height: causticsResolution, depthOrArrayLayers: 1 }
            );

            const linearSampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
                addressModeU: 'clamp-to-edge',
                addressModeV: 'clamp-to-edge'
            });

            async function loadTextureFromURL(url) {
                const res = await fetch(url);
                const blob = await res.blob();
                const image = await createImageBitmap(blob);
                const texture = device.createTexture({
                    size: [image.width, image.height, 1],
                    format: 'rgba8unorm',
                    // Include RENDER_ATTACHMENT because some platforms blit during copyExternalImageToTexture.
                    usage: uploadTextureUsage
                });
                device.queue.copyExternalImageToTexture(
                    { source: image },
                    { texture },
                    [image.width, image.height]
                );
                return texture;
            }

            const skyTexture = await loadTextureFromURL('tiles.jpg');

            const heightModule = device.createShaderModule({ code: shaders.height });
            const gravityModule = device.createShaderModule({ code: shaders.gravity });
            const renderModule = device.createShaderModule({ code: shaders.render });
            const causticsModule = device.createShaderModule({ code: shaders.caustics });

            const vertexBufferLayout = {
                arrayStride: 8,
                attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }]
            };

            const heightPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: heightModule, entryPoint: 'vs_main', buffers: [vertexBufferLayout] },
                fragment: {
                    module: heightModule,
                    entryPoint: 'fs_main',
                    targets: [{ format: 'rgba16float' }]
                },
                primitive: { topology: 'triangle-list' }
            });

            const gravityPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: gravityModule, entryPoint: 'vs_main', buffers: [vertexBufferLayout] },
                fragment: {
                    module: gravityModule,
                    entryPoint: 'fs_main',
                    targets: [{ format: 'rgba16float' }]
                },
                primitive: { topology: 'triangle-list' }
            });

            const causticsPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: causticsModule, entryPoint: 'vs_main', buffers: [vertexBufferLayout] },
                fragment: {
                    module: causticsModule,
                    entryPoint: 'fs_main',
                    targets: [{ format: 'rgba16float' }]
                },
                primitive: { topology: 'triangle-list' }
            });

            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: { module: renderModule, entryPoint: 'vs_main', buffers: [vertexBufferLayout] },
                fragment: {
                    module: renderModule,
                    entryPoint: 'fs_main',
                    targets: [{ format: canvasFormat }]
                },
                primitive: { topology: 'triangle-list' }
            });

            const heightUniformBuffer = device.createBuffer({
                size: 128,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            const gravityUniformBuffer = device.createBuffer({
                size: 32,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            const causticsUniformBuffer = device.createBuffer({
                size: 128,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });
            const renderUniformBuffer = device.createBuffer({
                size: 128,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
            });

            const heightBindGroup = device.createBindGroup({
                layout: heightPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: heightUniformBuffer } },
                    { binding: 1, resource: linearSampler },
                    { binding: 2, resource: heightTexture1.createView() }
                ]
            });

            const gravityBindGroup = device.createBindGroup({
                layout: gravityPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: gravityUniformBuffer } },
                    { binding: 1, resource: linearSampler },
                    { binding: 2, resource: heightTexture0.createView() }
                ]
            });

            const causticsBindGroup = device.createBindGroup({
                layout: causticsPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: causticsUniformBuffer } },
                    { binding: 1, resource: linearSampler },
                    { binding: 2, resource: heightTexture1.createView() }
                ]
            });

            const renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: renderUniformBuffer } },
                    { binding: 1, resource: linearSampler },
                    { binding: 2, resource: heightTexture1.createView() },
                    { binding: 4, resource: causticsTexture.createView() },
                    { binding: 5, resource: skyTexture.createView() }
                ]
            });

            let mouseDown = false;
            let mouseMoved = false;
            let mouseClicked = false;
            let mouseX = 0;
            let mouseY = 0;
            const eyeCoordinate = { radius: 4, phi: 0.785, theta: 0.785 };
            const lights = [
                [2.0, 2.0, 2.0],
                [-2.0, 2.0, -2.0],
                [0.0, 2.0, 0.0]
            ];
            const startTime = performance.now();

            function resizeCanvas() {
                const devicePixelRatio = window.devicePixelRatio || 1;
                const width = Math.floor(canvas.clientWidth * devicePixelRatio);
                const height = Math.floor(canvas.clientHeight * devicePixelRatio);
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                }
                context.configure({
                    device,
                    format: canvasFormat,
                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
                    alphaMode: 'opaque'
                });
                return { width, height };
            }

            function handleMouseDown(e) {
                mouseDown = true;
                mouseMoved = false;
                mouseX = e.clientX;
                mouseY = e.clientY;
            }

            function handleMouseUp(e) {
                mouseDown = false;
                mouseClicked = !mouseMoved;
            }

            function handleMouseMove(e) {
                if (!mouseDown) return;
                mouseMoved = true;
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                eyeCoordinate.theta += (deltaX / 10) / 180 * Math.PI;
                eyeCoordinate.phi += (-deltaY / 10) / 180 * Math.PI;
                mouseX = e.clientX;
                mouseY = e.clientY;
            }

            function handleWheel(e) {
                const newRadius = eyeCoordinate.radius + e.deltaY / 100.0;
                if (newRadius > 0.0) {
                    eyeCoordinate.radius = newRadius;
                }
            }

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('touchstart', (e) => handleMouseDown(e.touches[0]));
            canvas.addEventListener('touchend', (e) => handleMouseUp(e.changedTouches[0]));
            canvas.addEventListener('touchmove', (e) => {
                handleMouseMove(e.touches[0]);
                e.preventDefault();
            }, { passive: false });

            function updateUniforms(screen) {
                const now = performance.now();
                const time = (now - startTime) / 1000;

                const heightArray = new ArrayBuffer(64);
                const heightFloats = new Float32Array(heightArray);
                const heightUints = new Uint32Array(heightArray);
                heightFloats[0] = simResolution;
                heightFloats[1] = simResolution;
                heightFloats[2] = time;
                heightUints[3] = mouseClicked ? 1 : 0;
                const dpr = window.devicePixelRatio || 1;
                heightFloats[4] = mouseX * dpr;
                heightFloats[5] = mouseY * dpr;
                heightFloats[6] = screen.width;
                heightFloats[7] = screen.height;
                heightFloats[8] = eyeCoordinate.radius;
                heightFloats[9] = eyeCoordinate.phi;
                heightFloats[10] = eyeCoordinate.theta;
                device.queue.writeBuffer(heightUniformBuffer, 0, heightArray);

                const gravityArray = new Float32Array([simResolution, simResolution, 0, 0]);
                device.queue.writeBuffer(gravityUniformBuffer, 0, gravityArray.buffer);

                const causticsArray = new Float32Array(20);
                causticsArray[0] = time;
                causticsArray.set(lights[0], 4);
                causticsArray.set(lights[1], 8);
                causticsArray.set(lights[2], 12);
                device.queue.writeBuffer(causticsUniformBuffer, 0, causticsArray.buffer);

                const renderArray = new Float32Array(20);
                renderArray[0] = screen.width;
                renderArray[1] = screen.height;
                renderArray[2] = time;
                renderArray[4] = eyeCoordinate.radius;
                renderArray[5] = eyeCoordinate.phi;
                renderArray[6] = eyeCoordinate.theta;
                renderArray.set(lights[0], 8);
                renderArray.set(lights[1], 12);
                renderArray.set(lights[2], 16);
                device.queue.writeBuffer(renderUniformBuffer, 0, renderArray.buffer);
            }

            function draw() {
                const screen = resizeCanvas();
                updateUniforms(screen);

                const commandEncoder = device.createCommandEncoder();

                const heightPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: heightTexture0.createView(),
                        loadOp: 'clear',
                        storeOp: 'store',
                        clearValue: { r: 0, g: 0, b: 0, a: 0 }
                    }]
                });
                heightPass.setPipeline(heightPipeline);
                heightPass.setBindGroup(0, heightBindGroup);
                heightPass.setVertexBuffer(0, quadBuffer);
                heightPass.draw(6, 1, 0, 0);
                heightPass.end();

                const gravityPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: heightTexture1.createView(),
                        loadOp: 'clear',
                        storeOp: 'store',
                        clearValue: { r: 0, g: 0, b: 0, a: 0 }
                    }]
                });
                gravityPass.setPipeline(gravityPipeline);
                gravityPass.setBindGroup(0, gravityBindGroup);
                gravityPass.setVertexBuffer(0, quadBuffer);
                gravityPass.draw(6, 1, 0, 0);
                gravityPass.end();

                const causticsPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: causticsTexture.createView(),
                        loadOp: 'clear',
                        storeOp: 'store',
                        clearValue: { r: 0, g: 0, b: 0, a: 0 }
                    }]
                });
                causticsPass.setPipeline(causticsPipeline);
                causticsPass.setBindGroup(0, causticsBindGroup);
                causticsPass.setVertexBuffer(0, lightWaveBuffer);
                causticsPass.draw(lightWaveVertices.length / 2, 1, 0, 0);
                causticsPass.end();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        storeOp: 'store',
                        clearValue: { r: 0, g: 0, b: 0, a: 1 }
                    }]
                });
                renderPass.setPipeline(renderPipeline);
                renderPass.setBindGroup(0, renderBindGroup);
                renderPass.setVertexBuffer(0, quadBuffer);
                renderPass.draw(6, 1, 0, 0);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);
                mouseClicked = false;
                requestAnimationFrame(draw);
            }

            draw();
        })();
    </script>
</body>
</html>
